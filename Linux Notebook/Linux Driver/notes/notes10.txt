主题：	
	1.char驱动的子系统
	2.input子系统
	3.input子系统的核心结构体
	4.FT5206电容屏的input驱动(IIC总线)
	5.tty子系统
	6.fb子系统
	7.v4l2子系统
	8.alsa子系统


1. char驱动的子系统
=======================
(1)char驱动子系统的作用
---------------------
子系统要负责创建/dev/下的设备文件，并为一类设备提供通用的控制方法；


(2)子系统可以让用户态接口尽量稳定
--------------------------
由于用户态访问设备文件时，首先要调用子系统的代码。因此，子系统尽量保持代码对用户态稳定(尤其是ioctl命令稳定)。如果硬件或内核有变化，基本上不用修改用户态的应用程序。


(3)几种最常见的char驱动子系统
--------------------------
input
tty
fb(frame-buffer)
v4l2(video for linux 2)
alsa(advanced linux sound architecture)




2.INPUT子系统
========================
(1)针对的设备类型
-----------------------
输入子系统，针对鼠标，键盘，按键，触摸屏等

(2)设备文件
-----------------------
输入子系统创建的设备文件位于/dev/input目录下的event*和mouse*
为了知道每个设备文件对应哪个硬件，可以参考input子系统提供的proc文件：
/proc/bus/input/devices

(3)内核代码位置
-----------------------
input子系统和驱动的实现代码位于内核中的drivers/input子目录下；
其中，input.c和evdev.c是input子系统实现的核心文件；
mouse，touchscreen等子目录下是input驱动的实现;

input子系统还有自己的头文件<linux/input.h>；
有些内容只供input驱动使用，还有些内容可以供用户态app使用；
这个头文件在内核源码linux-3.0.86/include/linux/下；
在用户态的/usr/include目录下，也有该头文件；


(4)参考资料
---------------------
关于input驱动的设计，可以参考精通一书第7章


(5)用户态测试例子
------------------------
例子见drv-arm/07input/01itest/
目录下有3个用户态测试例子，可以解读驱动传给用户态的input_event结构体，也可以向鼠标等设备注入事件；



2. TTY子系统
=====================
(1)针对的设备类型
---------------------
tty子系统也可以称为终端子系统，传统的终端是显示器和键盘的组合，对于嵌入式设备来说，针对的主要是UART串口设备；

(2)设备文件
---------------------
tty子系统创建的设备文件在/dev目录下：
tty0~tty63是显示器加键盘的组合；
ttyS0~S3是pc上的串口；
ttySAC0~ttySAC3是4412上的串口文件；
ttyUSB0是usb串口对应的设备文件；
tty驱动可以选择自己设备的主设备号，起始次设备号等;


(3)内核代码位置
---------------------
tty子系统的代码位于linux-3.0.86/drivers/tty目录，包括tty_io.c，tty_buffer.c等；

tty驱动的代码则位于drivers下面的很多位置，比如usb串口的tty驱动位于drivers/usb/serial目录下；

e4412的串口驱动则位于drivers/tty/serial目录下，包括serial_core.c，samsung.c和s5pv210.c，其中s5pv210.c为串口驱动的platform_driver封装；具体的驱动在前两个文件中；


(4)参考资料
-----------------------
关于tty驱动的设计，可以参考LDD3书的第18章，以及精通linux驱动一书第六章；
关于tty应用程序的设计，参考APUE书的第18章"终端IO"；
在glibc中定义了若个库函数，封装了对tty设备的ioctl命令，可以用man手册查看，如tcgetattr，tcsetattr等


(5)用户态测试例子
------------------------
tty应用程序的例子见08tty/目录下的tty_read.c和tty_write.c



3.FB子系统(Frame Buffer)
=========================
(1)针对的设备类型
----------------------
fb即frame buffer，即显示子系统；
包括芯片内部的显示控制器，以及外面连接的LCD、VGA、HDMI等显示设备；

4412内部的第41章描述了显示控制器；该控制器通过并行线连接到开发板的LCD屏幕；咱们的板子LCD屏的分辨率为800*480


(2)设备文件
----------------------
fb子系统在用户态创建的设备文件为/dev/fb*，用户态可以准备一张bmp图片，将其写入fb文件，屏幕上就会出现图片的内容；
如果在4412开发板上，则设备文件为/dev/graphics/fb*;


(3)内核代码位置
-----------------------
fb子系统的代码位于drivers/video/目录下，包含fbmem.c等；

4412的fb驱动的实现代码位于drivers/video/samsung/目录下，4412的fb驱动由s3cfb_ops.c,s3cfb_main.c和s3cfb_fimd6x.c构成；


(4)参考资料
---------------------
关于fb驱动的设计，可以参考精通linux驱动设计一书第12章
还可以参考内核中drivers/video/s3c2410fb.c，这个是老的S3C2410处理器的fb驱动；


(5)用户态测试例子
---------------------
例子见drv-arm/09fb目录下的fb01.c和fb02.c
fb01.c是通过ioctl命令从/dev/fb设备文件获取硬件信息；

fb02.c的工作是在用户态将一个点阵式图片(bmp)用mmap的方式写入/dev/fb，在屏幕上会出现该图片；




4. V4L2子系统
======================
(1)针对的设备类型
-----------------------
V4L2即Video for Linux 2，为视频(多媒体)子系统；
主要针对摄像头、电视卡等视频流的设备，还可以针对一些多媒体设备，比如4412内部的JPEGcodec，MFCcodec，ImageRotator等，三星都提供了对应的v4l2驱动；

(2)设备文件
-----------------------
v4l2设备在用户态的设备文件是/dev/video*；
如果连接的是usb摄像头，一般在pc上的设备文件为/dev/video0;
如果是在4412开发板上，v4l2设备的文件也对应/dev/video*，但4412将JPEGcodec等也识别为video文件；
可以参考/sys/class/video4linux/videox/name文件(x可以是0/1/2/3等)，确定/dev/下的video文件对应哪个设备；


(3)内核代码位置
-----------------------
v4l2子系统的相关代码位于drivers/media/video目录下，包括v4l2-ioctl.c，v4l2-dev.c等;

如果采用USB摄像头，则linux提供统一的UVC驱动(USB Video Capture);
uvc驱动代码位于drivers/media/video/uvc目录下；

如果从淘宝上采购了友善配套的ov5640摄像头，则该摄像头和4412内部的摄像头接口相连，将该摄像头模块连接到开发板的CON17接口(20pin)；
相关的驱动分为两部分，一部分是4412摄像头接口的驱动，一部分是外接的摄像头模块的驱动；

4412的摄像头接口驱动位于drivers/media/video/samsung/fimc目录下；
包括fimc_capture.c, fimc_dev.c, fimc_regs.c等，代码超过1万行了；

外接的摄像头模块为OmiVision的ov5640，但友善没有提供对应的源代码，只提供了ov5640.ko，可以在android5.0下使用；
可以参考drivers/media/video目录下的ov9640.c等代码，自己写ov5640.c；
写用户态app时，还可以参考android5.0源码下面的摄像头访问库


(4)参考资料
--------------------
关于v4l2驱动的设计，没有太多可供参考的资料。。。

关于v4l2应用程序的设计，可以参考drv-arm/11v4l2/docs目录下的v4l2.pdf，该文档是v4l2用户态API的参考文档；


(5)用户态测试例子
---------------------
在drv-arm/11v4l2/目录下，还有很多我写的用户态测试程序，适用于usb摄像头；
尤其是catch03.c，该程序捕获摄像头信息，将数据存储为jpeg图片；
还可以用用户态的库，如ffmpeg，将捕获到的摄像头信息进一步转换成mpeg或h.263/h.264的视频流
更进一步，还可以利用4412内部的MFCCodec(硬件编解码器)来实现视频流的编码



5.ALSA子系统
=========================
(1)针对的设备类型
----------------------
音频子系统，Advanced Linux Sound Architecture
早期的音频子系统为OSS(Open Sound System)，目前已经被淘汰
针对音频类设备，包括arm芯片内部的音频控制器，以及外接的音频Codec芯片；

(2)设备文件
----------------------
input/tty/fb/v4l2等子系统，都是一个硬件对应一个/dev/下的设备文件；
alsa子系统比较特殊，一个声音设备会对应/dev/下的多个设备文件；见/dev/snd目录，下面有多个和音频播放对应的文件；

ALSA子系统并不提倡用户态直接操作设备文件，而是封装了一套用户态的alsa库，用户写音频的应用程序，都要通过调用库函数来播音，录音等；


(3)内核代码位置
-----------------------
alsa子系统的内核代码位于linux-3.0.86/sound目录下，而非drivers目录，要特别注意；
子系统的核心代码基本都集中在sound/core/目录下，比如pcm.c，sound.c等
alsa驱动的代码位于sound/soc/samsung目录下，如snd-soc-i2s.c等；

开发板上基于I2S接口外接的音频codec为wm8960，友善没有提供该codec驱动的源代码，只是提供了对应的.ko文件；可以参考sound/soc/codecs/目录下的wm8960.c/wm8960.h


(4)参考资料
------------------------
关于音频驱动的设计，可以参考精通linux驱动一书第13章;
音频驱动也比较复杂，但应该比v4l2要简单一些；

关于音频驱动的用户态应用程序设计，目前没有特别合适的参考书或资料。


(5)用户态的测试例子
------------------------
用户态的例子可以参考drv-arm/11alsa目录下的02wav_play.c
该例子是在用户态下，利用alsa库打开音频文件，播放wave格式的音乐；



2.input子系统
=========================
针对触摸屏，鼠标，键盘，按键等设备。
如果想和用户态的qt等能够接收鼠标、键盘等设备输入的应用程序结合，那么就要在内核中提供input驱动。

(1)input子系统在用户态的特征
创建的设备文件在/dev/input目录下，名字为eventx等;
在/sys/class/input目录下，是系统中所有的input设备(input子系统负责创建class结构体);
input子系统还在/proc/bus/input目录下创建了文件devices和handlers，其中devices列出了系统中的所有input设备


(2)input子系统的内核相关代码
input子系统的实现代码在drivers/input目录;
相关的头文件是<linux/input.h>;
周末可以看看input子系统的实现代码，包括input.c以及evdev.c(定义file_operations)

input子系统负责生成/dev/下的设备文件，参考/dev/input目录，其中有多个设备文件，每个文件和实际的input硬件对应。

要了解每个设备文件对应哪些硬件，可以参考/proc/bus/input/devices文件



3.input子系统的核心结构体
=========================
(1)input_event
定义在<linux/input.h>
由驱动生成，每个input_event对应设备的一次行为。
比如按键的一次抬起或按下，或者是触摸屏/鼠标等产生的一次坐标；
驱动准备好input_event后，要提交给input子系统。input子系统会为每个设备构建一个缓冲区来存储input_event，当用户态有人读/dev/input/eventx文件时，读到的就是一个个的input_event

每个input_event中含有type,code,value三个信息，合在一起表示按键或坐标信息


(2)input_dev
定义在<linux/input.h>
该结构体由input子系统设计，要求驱动来分配并初始化。每当驱动要支持一个实际存在的设备时，就需要分配并初始化一个input_dev，然后注册到input子系统中。
只有注册过input_dev，input子系统才会在/dev/input下创建对应的设备文件。

input_dev是子系统要求为每个实际存在设备创建的结构体，和以前学过的xx_priv结构体不冲突。实际中，驱动经常同时为每个设备分配input_dev和xx_priv结构，但只需要向子系统注册input_dev即可。

几乎所有的子系统都和input子系统的设计思路类似，子系统要求驱动为每个支持的设备提供一个结构体。input子系统为input_dev；网络子系统为net_device；fb子系统为fb_info；块子系统为gendisk



4. FT5206电容屏控制器驱动
==========================
电容屏的电路图见datasheet/lcd/目录下的s701图
根据电路图，电容屏的控制芯片为FT5206，该芯片内部包括一个8051，以及厂商提供的程序。
实质上，4412和FT5206间是通讯的关系，当手指按到电容屏上的时候，FT5206的程序自动探测手指的位置，并进行计算，然后将计算结果存入内部的寄存器。

手指的坐标确定以后，FT5206会通过外部中断(EINT14)来通知4412.4412收到中断后，应该在中断处理函数中，通过I2C控制器2，来访问FT5206，并从寄存器中读出坐标信息。

EINT14为中断，对应4412的引脚GPX1_6，可以用EXYNOS4_GPX1(6)宏来获得引脚的GPIO号；
再用gpio_to_irq()获取对应的中断号；

注意！根据电路图，FT5206应该和4412内部的I2C2控制器相连，但实际上，应该连接I2C1控制器。


...


